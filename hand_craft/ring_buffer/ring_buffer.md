## Ring Buffer

ring buffer，环形缓冲区，在处理生产者-消费者模型时，比较有优势。考虑这样的场景，在一个系统中，有多个线程不断地产生数据（生产者），同时又有其他线程持续的处理消耗这些数据（消费者），ring buffer 就能够很好地在两者之间起到缓冲和协调作用。

线程安全在多线程下是必须要考虑的问题，多个线程对 ring buffer 进行读写操作的时候，需要通过合理的机制来保证数据的一致性和操作的原子性。


一般构建一个环形缓冲区需要一段连续的内存空间以及四个指针：

* pHead，指向内存空间首地址
* pTail，指向内存空间的尾地址
* pRead，读指针
* pWrite，写指针


线程安全问题：

* 锁机制，在线程访问 ring buffer 之前，需要先获取锁，若无法获取锁，就需要等待，知道其他线程释放锁。但是锁机制会带来额外的开销，并且可能出现死锁的情况
* 原子操作，通过原子指令，保证对数据的操作不可分割，不被其他线程打断
* 无锁数据结构，通过巧妙设计，避免使用锁，提高并发性能，实现难度较大


### 1 naive 实现

在实现上，有两个指针，head和tail，在队尾写入，移动尾指针；在队头读取，移动头指针。使用数组来存储数据，一次性分配好，写入超过数组末尾时，会回绕到开始位置继续写入，读取也是类似的。

当头指针和尾指针相遇时，需要准确判断出，环形队列是空，还是满，从而决定是否可以继续写入，是否能够继续读取。

用一个变量 same_cycle，来完成对环形队列空/满的判断。

* 初始，head = 0, tail = 0，都指向环形队列的位置0处。把head或tail指针，在环形队列中转了完整一圈，叫一个轮次。初始，same_cycle = 1(true), 表示head和tail 两个指针是同一轮次的。
* 写入时，如果队列已满，则无法写入，直接返回失败。如果队列未满，则在tail 位置写入，tail移动至下一个位置(可能会回绕)。如果下一个位置为数组位置0，则表示开始了一个新的轮次，因此设置 same_cycle = 0(false)。
* 读取时，如果队列已空，则无法读取，直接返回失败。如果队列未空，则从head位置读取，head移动至下一个位置(可能会回绕)。如果下一个位置为数组位置0，则表示开始了一个新的轮次，与tail指针的轮次变得相同，因此设置 same_cycle = 1(true)。

因此环形队列为空的判断规则为：`(head == tail) && same_cycle`

环形队列已满的判断规则为：`(head == tail) && !same_cycle`


`ring_buffer_naive.h`

```cpp
#ifndef RING_BUFFER_NAIVE_H
#define RING_BUFFER_NAIVE_H
```