## 区间重叠问题

一般是会给定n个包含起始时间s和终止时间t的区间（s < t），这些区间之间可能会部分重叠。

三类问题：


### 1 最少会议室

区间起始和终止表示会议的开始和结束时间，求所需要的最小的会议室的数量。这个问题本质上是需要求最多的重叠数量。

一般解法，将所有的时间点排序，ret=0，遇到起点 +1，遇到终点 -1。

特殊情况处理，当同一时间点同时是一个区间的起点和另一个区间的终点的时候，需要先 -1，再 +1，不可反过来。即一般处理，终点优先级高于起点。

时间复杂度，O(nlogn)，主要在于排序 2n 个点。

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

bool cmp(const std::pair<int, int>x, const std::pair<int, int>y) {
    // 对于相同的时间点，使终点在起点前面
    if (x.first == y.first) return x.second > y.second;
    return x.first < y.first;
}

int main() {
    int n, s, t;
    n = 10;
    std::vector<std::pair<int, int>> vals;
    for (int i = 0; i < n; i++) {
        vals.push_back({i + 1, 0});
        vals.push_back({i + 8, 1});
    }
    sort(vals.begin(), vals.end(), cmp);
    int ret = 0;
    int cnt = 0;
    for (int i = 0; i < vals.size(); i++) {
        if (vals[i].second == 0) {
            cnt += 1;
            ret = ret > cnt ? ret : cnt;
        } else {
            cnt--;
        }
    }
    std::cout << "ret: " << ret << std::endl;
    return 0;
}
```


### 2 最多会议

在仅有一个会议室的情况下，求最多能满足的会议数量。即最多的无相互重叠的区间数量。

一般解法，贪心解法，按照会议结束时间排序，取第一个结束的会议，结束时间记为 end_t，遍历会议，安排第一个开始时间不小于 end_t 的会议，更新 end_t 为当前会议的结束时间。

特殊情况，若存在多个会议的结束时间相同，且开始时间都不小于 end_t，那么安排哪一个都可以。如果要求优先安排更长的会议，则选择开始时间更小的。

时间复杂度，主要在于排序，O(nlogn)

```cpp
#include <iostream>
#include <algorithm>
#include <vector>


bool cmp(std::pair<int, int>x, std::pair<int, int>y) {
    // 结束时间相同的，按照开始时间升序
    if (x.second == y.second) return x.first < y.first;
    // 按结束时间升序
    return x.second < y.second;
}


int main() {
    int n, s, t;
    n = 10;
    std::vector<std::pair<int, int>> vals;
    for (int i = 0; i < n; i++) {
        vals.push_back({i + 1, i + 3});
    }

    sort(vals.begin(), vals.end(), cmp);
    int ret = 0, end_t = -1;
    for (int i = 0; i < vals.size(); i++) {
        if (vals[i].first >= end_t) {
            ret += 1;
            end_t = vals[i].second;
        }
    }
    std::cout << "ret: " << ret << std::endl;
    return ret;
}
```




### 3 最长会议总时长

在仅有一个会议室的情况下，求最长的能满足的会议时间。即最多无相互重叠的区间长度之和。

使用动态规划求解。dp[i] 表示安排排序后的第 i 个会议后，总的最长会议总长度。那么状态转移方程可以写成：

dp[i] = vals[i].second - vals[i].first + max(dp[0], dp[1], ..., dp[i-1])

要保证 vals[i] 能够被安排，那么其前面被安排的那个会议的结束时间不能大于 vals[i] 的开始时间。

时间复杂度， 排序 O(nlogn)，动态规划 O(n^2)

```cpp
#include <iostream>
#include <algorithm>
#include <vector>


bool cmp(std::pair<int, int>x, std::pair<int, int>y) {
    // 结束时间相同的，按照开始时间升序
    if (x.second == y.second) return x.first < y.first;
    // 按结束时间升序
    return x.second < y.second;
}


int main() {
    int n, s, t;
    n = 10;
    std::vector<std::pair<int, int>> vals;
    for (int i = 0; i < n; i++) {
        vals.push_back({i + 1, i + 3});
    }
    int ret = 0;
    std::vector<int> dp(vals.size(), 0);
    sort(vals.begin(), vals.end(), cmp);
    for (int i = 0; i < vals.size(); i++) {
        // 在已经计算过的范围内计算 dp[i] 最大值
        int max_dpj = 0;
        for (int j = 0; j < i; j++) {
            // 考虑安排 vals[i] 的前提是前面的会议的结束时间不能超过 vals[i]的开始时间
            if (vals[j].second <= vals[i].first) {
                max_dpj = max_dpj > dp[j] ? max_dpj : dp[j];
            }
        }
        dp[i] = vals[i].second - vals[i].first + max_dpj;
        ret = ret > dp[i] ? ret : dp[i];
    }
    std::cout << "ret: " << ret << std::endl;
    return ret;
}
```
