61. 旋转链表

给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。
 

示例 1：
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]

示例 2：
输入：head = [0,1,2], k = 4
输出：[2,0,1]
 

提示：

链表中节点的数目在范围 [0, 500] 内
-100 <= Node.val <= 100
0 <= k <= 2 * 109


* 节点向右移动 k 个位置  ===>  相当于 节点向左移动 (len-k) 个位置

节点向左移动 就比较好写: 每移动一次,把头节点连接到尾节点。

考虑到 K 可能会很大，那么向右移动 k 等价向右移动 k%len，等价向左移动 len - k%len，即把链表前面的 len-k%len 个节点一次接到尾部

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if (!head || !head->next || k == 0)  return head;
        int length = 1;
        ListNode* lastNode = head;
        while (lastNode->next) {
            length++;
            lastNode = lastNode->next;
        }
        if (k == length)    return head;
        // k = k > length ? (k % length) : k;
        // while(k != length) {
        for (int i = 0; i < length - k%length; i++) {
            lastNode->next = head;
            head = head->next;
            lastNode = lastNode->next;
            lastNode->next = nullptr;
        }
        return head;
    }
};
```
