876. 链表的中间结点

给你单链表的头结点 head ，请你找出并返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

 

示例 1：
输入：head = [1,2,3,4,5]
输出：[3,4,5]
解释：链表只有一个中间结点，值为 3 。

示例 2：
输入：head = [1,2,3,4,5,6]
输出：[4,5,6]
解释：该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点。
 

提示：

链表的结点数范围是 [1, 100]
1 <= Node.val <= 100


* 两次遍历

第一次计算链表长度，第二次查找中间节点

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        int cnt = 0;
        ListNode* curr = head;
        while (curr) {
            cnt++;
            curr = curr->next;
        }
        curr = head;
        int mid = (cnt) / 2;
        for (int i = 0; i < mid; i++) {
            curr = curr->next;
        }
        return curr;

    }
};
```


* 快慢指针

快指针一次走两步，慢指针一次走一步，快指针走到末尾时，慢指针刚好在中间节点。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        if (!head->next) return head;
        if (!head->next->next) return head->next;
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast) {
            fast = fast->next;
            if (!fast) break;
            else {
                fast = fast->next;
                slow = slow->next;
            }
        }
        return slow;
    }
};
```
