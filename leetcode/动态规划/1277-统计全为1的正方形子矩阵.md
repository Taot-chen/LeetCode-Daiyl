1277. 统计全为 1 的正方形子矩阵

给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。

 

示例 1：
输入：matrix =
[
  [0,1,1,1],
  [1,1,1,1],
  [0,1,1,1]
]
输出：15
解释： 
边长为 1 的正方形有 10 个。
边长为 2 的正方形有 4 个。
边长为 3 的正方形有 1 个。
正方形的总数 = 10 + 4 + 1 = 15.

示例 2：
输入：matrix = 
[
  [1,0,1],
  [1,1,0],
  [1,1,0]
]
输出：7
解释：
边长为 1 的正方形有 6 个。 
边长为 2 的正方形有 1 个。
正方形的总数 = 6 + 1 = 7.
 

提示：

1 <= arr.length <= 300
1 <= arr[0].length <= 300
0 <= arr[i][j] <= 1


直接遍历所有数，找到一个1就以它为左上角尝试扩张正方形，每次扩张检测新加入的数有没有0，有就停止扩张；否则就找到一个全1阵，ans加1。按此种方法找到的全1阵要么大小不同，要么左上角坐标不同，故一定不会重复。

```cpp
class Solution {
public:
    int countSquares(vector<vector<int>>& matrix) {
        int ret = 0;
        int n = matrix.size();
        int m = matrix[0].size();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix[i][j]) {
                    int flag = 1;
                    for (int k = 0; k < min(n-i, m-j) && flag; k++) {
                        for (int l = i; l <= i + k && flag; l++) flag = matrix[l][j+k];
                        for (int l = j; l <= j + k && flag; l++) flag = matrix[i+k][l];
                        ret += flag;
                    }
                }
            }
        }
        return ret;
    }
};
```

