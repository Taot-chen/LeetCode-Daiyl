98. 验证二叉搜索树

给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。

有效 二叉搜索树定义如下：

节点的左子树只包含 严格小于 当前节点的数。
节点的右子树只包含 严格大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
 

示例 1：
输入：root = [2,1,3]
输出：true

示例 2：
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
 

提示：

树中节点数目范围在[1, 104] 内
-231 <= Node.val <= 231 - 1



* 递归

如果该二叉树的左子树不是空的，那么左子树的节点的值都小于当前节点；如果右子树不是空的，那么右子树的节点的值都小于当前节点；左右子树都是二叉搜索树。很明显的递归问题。

需要注意数据范围，使用 long long int。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool helper_func(TreeNode* root, long long int lower, long long int upper) {
        if (root == nullptr) return true;
        if (root->val <= lower || root->val >= upper) return false;
        return helper_func(root->left, lower, root->val) && helper_func(root->right, root->val, upper);
    }

    bool isValidBST(TreeNode* root) {
        return helper_func(root, LONG_MIN, LONG_MAX);
    }
};
```



* 中序遍历

递归都可写成迭代形式.

基于递归的方法，直到中序遍历二叉搜索树的结果是升序的，因此可以使用中序遍历的方法来价差当前节点是否大于前一个访问到的节点的值。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> s;
        long long int pre_val = LONG_MIN;
        while(!s.empty() || root != nullptr) {
            while (root != nullptr) {
                s.push(root);
                root = root->left;
            }
            root = s.top();
            s.pop();
            if (pre_val >= root->val) return false;
            pre_val = root->val;
            root = root->right;
        }
        return true;
    }
};
```

