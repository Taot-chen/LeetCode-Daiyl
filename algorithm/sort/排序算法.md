## 排序算法

### 1 冒泡排序

平均 O(n^2)，最坏 O(n^2)，最好 O(n)

遍历比较交换。

```cpp
std::vector<int> blob_sort(std::vector<int> input) {
    for (int i = 0; i < input.size(); i++) {
        for (int j = i; j < input.size(); j++) {
            if (input[i] > input[j]) {
                int tmp = input[i];
                input[i] = input[j];
                input[j] = tmp;
            }
        }
    }
    return input;
}
```




### 2 插入排序

平均 O(n^2)，最坏 O(n^2)，最好 O(n)

将列表分为已排序部分和未排序部分。初始时，已排序部分只包含第一个元素，未排序部分包含剩余元素。从未排序部分中取出第一个元素。将该元素与已排序部分的元素从后向前依次比较，找到合适的位置插入。

```cpp
std::vector<int> insert_sort(std::vector<int> input) {
    for (int i = 1; i < input.size(); i++) {
        int curr = input[i];
        int j = i - 1;
        while (j >= 0 && curr < input[j]) {
            input[j+1] = input[j];
            j--;
        }
        input[j+1] = curr;
    }
    return input;
}
```



### 3 选择排序

平均 O(n^2)，最坏 O(n^2)，最好 O(n^2)

将列表分为已排序部分和未排序部分。初始时，已排序部分为空，未排序部分为整个列表。在未排序部分中查找最小的元素。将找到的最小元素与未排序部分的第一个元素交换位置。将未排序部分的起始位置向后移动一位，扩大已排序部分的范围。

```cpp
std::vector<int> select_sort(std::vector<int> input) {
    for (int i = 0; i < input.size() - 1; i++) {
        int min_index = i;
        for (int j = i + 1; j < input.size(); j++) {
            if (input[j] < input[min_index]) min_index = j;
        }
        int tmp = input[i];
        input[i] = input[min_index];
        input[min_index] = tmp;
    }
    return input;
}
```



### 4 快速排序

平均 O(nlogn)，最坏O(n^2)

快排基于分治的思想，先随机选一个基准元素，将列表分为大于基准元素和小于基准元素的两部分，之后再递归地在这两部分进行排序。

从列表中选择一个元素作为基准（pivot）。选择方式可以是第一个元素、最后一个元素、中间元素或随机元素。将列表重新排列，使得所有小于基准元素的元素都在基准的左侧，所有大于基准元素的元素都在基准的右侧。对基准元素左侧和右侧的子列表分别递归地进行快速排序。

```cpp
int parition(std::vector<int>& input, int low, int high) {
    int povit = input[low];
    while (low < high) {
        while (low < high && input[high] >= povit) {
            high--;
        }
        input[low] = input[high];
        while (low < high && input[low] <= povit) {
            low++;
        }
        input[high] = input[low];
    }
    input[low] = povit;
    return low;
}

std::vector<int> quick_sort(std::vector<int> &input, int low, int high) {
    if (low < high) {
        int pivot = parition(input, low, high);
        quick_sort(input, low, pivot - 1);
        quick_sort(input, pivot + 1, high);
    }
    return input;
}
```


### 5 归并排序

稳定的 O(nlogn)。

将待排序的数组分成两个子数组，每个子数组包含大约一半的元素。递归地对每个子数组进行排序。将两个已排序的子数组合并成一个有序的数组。

```cpp
void merge(std::vector<int>& input, int start, int mid, int end) {
    std::vector<int> leftArray(input.begin() + start, input.begin() + mid + 1);
    std::vector<int> rightArray(input.begin() + mid + 1, input.begin() + end + 1);
    leftArray.insert(leftArray.end(), INT_MAX);
    rightArray.insert(rightArray.end(), INT_MAX);
    int idxLeft = 0, idxRight = 0;
    for (int i = start; i < end + 1; i++) {
        if (leftArray[idxLeft] >= rightArray[idxRight]) {
            input[i] = rightArray[idxRight];
            idxRight++;
        } else {
            input[i] = leftArray[idxLeft];
            idxLeft++;
        }
    }
}

void merge_sort(std::vector<int>& input, int start, int end) {
    if (start >= end) return;
    int mid = (start + end) / 2;
    merge_sort(input, start, mid);
    merge_sort(input, mid+1, end);
    merge(input, start, mid, end);
}
```
