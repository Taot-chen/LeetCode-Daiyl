## 虚函数表和虚函数表指针

In One Word:

* 虚函数表在编译阶段，在 class 内遇到 virtual 关键字修饰的函数时创建
* 虚函数表在可执行程序里面存放在磁盘上，在执行的时候存在于内存中
* 程序运行期间，数据结构：`.bss`，未初始化以及初始化为 0 的全局变量和静态变量；`.data`，初始化的全局变量的静态变量；`.rodata`，只读数据段，虚函数表。数据区（静态存储区）包含`.bss`和`.data`；代码区包含`.text`和`.rodata`。
* 每个类只有一个全局共享的虚函数表，虚函数表是一个函数指针数组，数组中的每个成员存储一个虚函数的实际入口地址，顺序与类中虚函数的​​声明顺序一致​​。
* 虚表中始终包含析构函数的条目，确保通过基类指针删除派生类对象时调用正确的析构函数；未实现的纯虚函数在虚表中用占位符（如 `__cxa_pure_virtual`）标记，调用时会终止程序;派生类重写基类虚函数时，虚表对应条目替换为派生类的函数地址（如 `Derived::func1` 覆盖 `Base::func1`）;派生类新增的虚函数追加到虚表末尾
* 每个对象实例内部隐式包含一个​​指向虚函数表的指针​​（vptr），位于对象内存布局的​​起始位置​​（32位系统占4字节，64位占8字节）
* 在对象构造期间，编译器自动将 vptr 初始化为指向​​当前类的虚函数表​​；构造函数中调用虚函数时，因 vptr 尚未完全设置，会静态绑定到当前类的版本（无法多态）
* 单继承​​：派生类对象只有一个 vptr，指向自己的虚表（含基类条目和重写/新增条目）；多继承​​：派生类对象包含​​多个 vptr​​（每个基类对应一个），按继承声明顺序排列
* 虚函数调用：
    * 通过 obj 获取 vptr：`vptr = *(void**)obj`
    * 查虚表：根据函数声明顺序计算偏移量（如 func1 的偏移为 `sizeof(void*) * 0`）
    * 获取函数地址：`func_addr = *(void**)((char*)vptr + offset)`
    * 调用函数：`func_addr(obj)`
