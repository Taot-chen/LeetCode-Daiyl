## 编译优化选项 -O0/-O1/-O2/-O3 的区别

In One Word:

* -O0，无优化，严格按源代码顺序生成机器码，保留所有变量和语句的原始逻辑。
* -O1，-O0 + 死代码消除、常量合并/折叠、简化表达式/公共子表达式消除、减少冗余寄存器操作。代码结构基本保留
* -O2，-O1 + 循环优化（循环展开、循环合并），函数内联（小型函数内联），指令调度（重排指令以利用CPU流水线），分支预测优化（减少跳转开销）。显著提高执行速度（通常 20%-50%），代码结构大幅调整
* -O3，-O2 + 高级循环变换​​（循环分块、交换），自动向量化​​（使用 SIMD 指令并行处理数据，如 SSE/AVX），大规模函数内联​​（突破 -O2的内联限制），伪寄存器网络​​（重命名寄存器提升并行度）。循环展开等优化可能导致代码体积膨胀，极端优化可能导致浮点计算精度问题，变量寄存器映射混乱导致调试困难
-Os，在 -O2基础上关闭增加代码体积的优化（如循环展开）



说明：

* 开发阶段​​：用 -O0 或 -Og（GCC 专为调试设计的优化）；​​测试/预发布​​：使用 -O1或 -O2平衡性能与可调试性；生产环境​​：默认 -O2，对计算密集型模块可局部测试 -O3；嵌入式设备​​：优先 -Os控制代码体积

* ​​-O1以上级别会重排/删除代码，可能掩盖内存错误或并发问题，调试时建议切回 -O0

* -O3的向量化可能因数据依赖或缓存失效导致性能下降，需实际测试验证

* -O0 与调试器（如 GDB）完全兼容，断点、变量查看等功能无干扰，可精准定位问题；-O1 代码结构基本保留，调试体验较好；-O2 代码结构大幅调整，调试信息可能不连贯；-O3 变量寄存器映射混乱，调试机器困难

