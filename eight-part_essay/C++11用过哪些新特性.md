## C++11用过哪些新特性

In One Word：

* 关键字&语法糖：auto，decltype，nullptr，final，override，constexpr，基于范围的 for，function函数对象（bind，lambda）--> 编程更便捷，更严谨，编译器做更多的事情
* stl 容器：array，forward_list，unordered_map，unordered_set
* 智能指针：shared_ptr，weak_ptr，unique_ptr
* 多线程：thread，mutex，lock_guard，condition_variable，atomic
* 右值引用：T&&，將亡值（触发移动构造，移动拷贝构造），实现移动语义（std::move），实现完美转发（万能引用T&&，forward）



----------

### 1 具体说明

#### 1.1 关键字

* auto：自动类型推导，不保留顶层 const 和引用，必须初始化（无初始值无法推导类型），不能用于函数参数、类非静态成员、数组定义

* decltype：表达式类型推导​，但是不会去计算表达式的值，保留顶层 const 和引用

* nullptr，替代 NULL 和 0，避免重载歧义和类型错误。`nullptr` 的类型为 `std::nullptr_t`，`NULL`是整数 0。nullptr 可隐式转换为任意指针类型（如 int*、char*），但不能转为整数

* final，禁止类被继承或虚函数被重写

* override，显式标记重写基类虚函数，防止签名错误

* constexpr，声明可在编译期求值的常量或函数，提升运行时性能

```cpp
constexpr int sq(int x) { return x * x; }
int arr[sq(3)]; // 数组大小为 9（编译期确定）
```

注：
  * 函数体必须足够简单（C++11 中仅含 return 语句）。
  * 参数和返回值需为字面类型（如整数、指针）
  * 可用于替代宏常量（如 `#define SIZE 100`）



#### 1.2 语法结构

* 基于范围的 for 循环，用于简化容器或数组的遍历，避免手动管理迭代器或索引。

```cpp
for (元素类型 变量名 : 容器/数组) { 
    // 循环体 
}
```

适用于数组、STL 容器（vector/list/map 等）、自定义支持 begin()/end() 的类型。

底层机制：

  * 容器 → 转换为迭代器遍历（`for (auto it = begin; it != end; ++it)`）
  * 数组 → 转换为传统 for 循环（通过首尾指针计算边界）


常用写法：

  * 只读访问 → `const auto&`（避免拷贝开销）。
  * 修改元素 → `auto&`（引用传递）。
  * 关联容器（如 map）→ 遍历键值对（`std::pair`）


优势：

  * 容器稳定性​​：循环中禁止增删容器元素（可能导致迭代器失效）。
  * ​​表达式求值​​：冒号后的表达式​​仅执行一次​​（先确定遍历范围）

  ```cpp
  for (auto val : getVector()) { /* getVector() 只调用一次 */ }
  ```



* 函数对象封装：`std::function`，统一封装任意可调用实体（函数指针、Lambda、函数对象、成员函数等），实现类型安全的回调机制

```cpp
#include <functional>
std::function<返回值类型(参数类型)> 函数对象;
```

​​封装普通函数​​：

```cpp
int add(int a, int b) {retuen a + b;}
std::function<int(int, int)> func = add;
```


封装 Lambda​​：

```cpp
auto lambda = [](int x){return x * x;};
std::function<int(int)> func = lambda;
```


​​封装成员函数​​：需结合 `std::bind`


效果：

  * 多态性​​：同一接口处理不同类型的可调用对象。
  * ​​类型安全​​：避免函数指针的类型不安全问题。
  * ​​回调机制​​：简化事件处理、策略模式实现



* lambda 表达式

```cpp
[捕获列表](参数列表) -> 返回类型 { 函数体 };
// 返回类型​​：可省略（编译器自动推断）
```

捕获列表​​：控制外部变量的访问方式：
  * `[=]`：值捕获所有外部变量（默认不可修改）。
  * `[&]`：引用捕获所有外部变量（可修改）。
  * `[x, &y]`：混合捕获（x 值捕获，y 引用捕获）。

`​​mutable​​`：允许修改值捕获的变量（不影响外部变量）

```cpp
int a = 0;
auto lambda [a]() mutable {a++;}; // 内部修改不影响外部 a
```


* 函数适配器：`std::bind`，基于已有可调用对象创建新函数，支持 feature：
  * ​​参数绑定​​：固定部分参数值。
  * ​​参数顺序调整​​：通过占位符（_1, _2）重排参数。
  * ​​成员函数绑定​​：将成员函数绑定到对象实例


绑定参数：

```cpp
void print(int a, int b) {/*...*/}
auto boun = std::bind(print, 10, std::placeholders::_1); // std::placeholders::_1 对应第一个参数，需与目标函数参数顺序匹配
bound(20);  // 等效于 print(10, 20)
```


​​绑定成员函数​​：

```cpp
class MyClass {
public:
    void func(int x) { /* ... */ }
};
MyClass obj;
auto call = std::bind(&MyClass::func, &obj, std::placeholders::_1);
call(100); // 调用 obj.func(100)
```


与 `std::function` 结合​:

```cpp
std::function<void(int)> callback = std::bind(print, 5, std::placeholders::_1);
```





#### 1.3 stl 容器

* array，数组，带迭代器

* forward_list，单向链表

* unordered_map，unordered_set，不排序 map，不排序 set



#### 1.4 智能指针

* shared_ptr, 包含引用计数的多引用指针

* weak_ptr，不影响引用计数的多引用指针

* unique_ptr，只能有一个指针指向目标对象的指针



#### 1.5 多线程

* thread，mutex，lock_guard，condition_variable，atomic

多线程的锁依靠系统级调度，在没有获取到锁的时候，线程休眠等待，达到同步的目的；atomic，是通过同步语义去标记需要同步的变量和操作，告诉 CPU 和编译器，不要对这些变量和操作做违反一致性的优化处理
